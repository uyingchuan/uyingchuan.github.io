<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小u</title>
  
  <subtitle>u影川的小屋</subtitle>
  <link href="https://uyc.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://uyc.gitee.io/"/>
  <updated>2020-08-27T08:50:16.293Z</updated>
  <id>https://uyc.gitee.io/</id>
  
  <author>
    <name>u影川</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript知识点小记(5)</title>
    <link href="https://uyc.gitee.io/2020/08/26/personal-notes/JavaScript/js-notes5/"/>
    <id>https://uyc.gitee.io/2020/08/26/personal-notes/JavaScript/js-notes5/</id>
    <published>2020-08-26T09:09:00.000Z</published>
    <updated>2020-08-27T08:50:16.293Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><h2 id="Document节点"><a href="#Document节点" class="headerlink" title="Document节点"></a>Document节点</h2><p><code>Document</code>节点代表整个文档</p><a id="more"></a><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><h4 id="快捷方式属性"><a href="#快捷方式属性" class="headerlink" title="快捷方式属性"></a>快捷方式属性</h4><ol><li><p>document.defaultView<br>返回<code>document</code>对象所属的<code>window</code>对象</p></li><li><p>document.doctype  </p></li><li><p>document.documentElement<br>返回当前文档的根元素节点，一般是<code>&lt;html&gt;</code></p></li><li><p>document.head, body</p></li><li><p>document.scrollingElement<br>返回文档的滚动元素，标准模式为<code>&lt;html&gt;</code>，兼容模式为<code>&lt;body&gt;</code></p></li><li><p>document.activeElement<br>返回获得当前焦点（focus）的DOM元素，没交点返回<code>&lt;body&gt;</code>元素或<code>null</code></p></li><li><p>document.fullscreenElement<br>返回当前以全屏状态展示的DOM元素</p></li></ol><h4 id="节点集合属性"><a href="#节点集合属性" class="headerlink" title="节点集合属性"></a>节点集合属性</h4><ol><li><p>document.links<br>返回当前文档所有设定了<code>href</code>属性的<code>&lt;a&gt;</code>及<code>&lt;area&gt;</code>节点</p></li><li><p>document.forms<br>返回所有<code>&lt;form&gt;</code>表单节点</p></li><li><p>document.images<br>返回页面所有<code>&lt;img&gt;</code>图片节点</p></li><li><p>document.embeds, document.plugins<br>都返回所有的<code>&lt;embed&gt;</code>节点</p></li><li><p>document.scripts<br>返回所有的<code>&lt;script&gt;</code>节点</p></li><li><p>document.styleSheets<br>返回所有文档内嵌或引入的样式表集合，<code>注：</code>只有这个返回不是<code>HTMLCollection</code>实例</p></li></ol><h4 id="文档静态信息属性"><a href="#文档静态信息属性" class="headerlink" title="文档静态信息属性"></a>文档静态信息属性</h4><ol><li><p>document.documentURI, document.URL<br>都返回当前文档网址字符串，继承自不同的接口</p></li><li><p>document.domain<br>返回当前文档的域名</p></li><li><p>document.location<br>拿到浏览器提供的原生对象<code>Location</code></p></li><li><p>document.lastModified<br>文档最后修改的时间的字符串，格式随浏览器</p></li><li><p>document.title<br>文档标题，可读写</p></li><li><p>document.characterSet<br>文档编码</p></li><li><p>document.referrer<br>返回当前访问者来自哪个网址，无法获取则空字符串</p></li><li><p>document.dir<br>文字方向，左：<code>rtl</code>，右：<code>ltr</code></p></li><li><p>document.compatMode<br><code>BackCompat</code>(向后兼容)和<code>CSS1Compat</code>(严格模式)，一般设置明确的<code>DOCTYPE</code>，值都为严格模式</p></li></ol><h4 id="文档状态属性"><a href="#文档状态属性" class="headerlink" title="文档状态属性"></a>文档状态属性</h4><ol><li><p>document.hidden<br>当前页面窗口是否可见</p></li><li><p>document.visibilityState<br>当前文档的可见状态，四种状态，visible hidden prerender<br>unloaded</p></li><li><p>document.readyState<br>当前文档的加载状态，三种值</p></li></ol><h4 id="document-cookie"><a href="#document-cookie" class="headerlink" title="document.cookie"></a>document.cookie</h4><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol><li><p>document.open(), close()<br>可写状态</p></li><li><p>document.write(), document.writeIn()<br>写入内容，后者会自行转行</p></li><li><p>document.querySelector(), document.querySelectorAll()<br>使用CSS选择器匹配元素节点，不支持伪元素选择器,后者返回<code>NodeList</code>对象</p></li><li><p>document.getElementsByTagName()<br>标签名匹配节点，返回<code>HTMLCollection</code>对象</p></li><li><p>document.getElementsByClassName()<br>按className匹配节点，返回<code>HTMLCollection</code>实例</p></li><li><p>document.getElementsByName()<br>根据<code>name</code>属性匹配HTML元素，返回<code>NodeList</code>实例</p></li><li><p>document.getElementById()<br>根据<code>id</code>匹配元素节点</p></li><li><p>document.createElement()<br>生成并返回元素节点，标签名可自定义</p></li><li><p>document.createTextNode()<br>生成并返回文本节点</p></li><li><p>document.createAttribute()<br>生成并返回属性节点</p></li><li><p>document.createComment()<br>生成并返回注释节点</p></li><li><p>document.createDocumentFragment()<br><code>DocumentFragment</code>是存在于内存当中的DOM片段，不属于当前文档，常用于生成一段较为复杂的DOM结构，再插入到当前文档，这样的好处是对他的改动不会触发网页的重新渲染。</p></li><li><p>document.createEvent()<br>生成并返回一个<code>Event</code>实例</p></li><li><p>document.addEventListener(), removeEventListener(), dispatchEvent()<br>继承自<code>EventTarget</code>接口，用于处理<code>document</code>节点的事件</p></li><li><p>document.hasFocus()<br>文档之间是否有元素被激活或获得焦点</p></li><li><p>document.adoptNode(), importNode<br>前者移除后者拷贝，从一个文档或片段将节点转移到当前文档</p></li><li><p>document.createNodeIterator()<br>返回body元素子节点的遍历器</p></li><li><p>document.createTreeWalker()<br>返回DOM的子树遍历器</p></li><li><p>document.execCommand()，document.queryCommandSupported()，document.queryCommandEnabled()  </p></li><li><p>document.getSelection()<br>指向<code>window.getSelection()</code></p></li></ol><h2 id="Element节点"><a href="#Element节点" class="headerlink" title="Element节点"></a>Element节点</h2><p><code>Element</code>继承了<code>Node</code>接口</p><ol><li><p>Element.attributes<br>返回所有属性节点组成的类数组对象</p></li><li><p>Element.className, Element.classList</p></li><li><p>Element.innerHTML<br>该元素包含的所有HTML代码，可读写</p></li><li><p>Element.outerHTML<br>当前元素节点的所有HMTL代码，包含自身</p></li><li><p>Element.style</p></li><li><p>Element.children</p></li><li><p>Element.firstElementChild, lastElementChild</p></li><li><p>Element.scrollIntoView()<br>滚动当前元素，进入浏览器的可视区域，类似于<code>window.location.hash</code></p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;DOM&quot;&gt;&lt;a href=&quot;#DOM&quot; class=&quot;headerlink&quot; title=&quot;DOM&quot;&gt;&lt;/a&gt;DOM&lt;/h1&gt;&lt;h2 id=&quot;Document节点&quot;&gt;&lt;a href=&quot;#Document节点&quot; class=&quot;headerlink&quot; title=&quot;Document节点&quot;&gt;&lt;/a&gt;Document节点&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Document&lt;/code&gt;节点代表整个文档&lt;/p&gt;</summary>
    
    
    
    <category term="personal-notes" scheme="https://uyc.gitee.io/categories/personal-notes/"/>
    
    
    <category term="JavaScript" scheme="https://uyc.gitee.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript知识点小记(4)</title>
    <link href="https://uyc.gitee.io/2020/08/26/personal-notes/JavaScript/js-notes4/"/>
    <id>https://uyc.gitee.io/2020/08/26/personal-notes/JavaScript/js-notes4/</id>
    <published>2020-08-26T06:09:00.000Z</published>
    <updated>2020-08-27T08:50:10.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><h3 id="一-DOM节点"><a href="#一-DOM节点" class="headerlink" title="一.DOM节点"></a>一.DOM节点</h3><ul><li>Document: 文档顶层节点</li><li>DocumentType: <code>doctype</code>标签</li><li>Element: 网页各种HTML标签</li><li>Attr: 网页元素的属性</li><li>Text: 标签之间或标签包含的文本</li><li>Comment: 注释</li><li>DocumentFragment: 文档的片段</li></ul><p>浏览器提供一个原生节点对象<code>Node</code>，上面其中节点都继承了<code>Node</code></p><a id="more"></a><h3 id="二-Node接口"><a href="#二-Node接口" class="headerlink" title="二.Node接口"></a>二.Node接口</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ol><li><p>Node.prototype.nodeType</p><ul><li>文档节点（document）：9，对应常量Node.DOCUMENT_NODE</li><li>元素节点（element）：1，对应常量Node.ELEMENT_NODE</li><li>属性节点（attr）：2，对应常量Node.ATTRIBUTE_NODE</li><li>文本节点（text）：3，对应常量Node.TEXT_NODE</li><li>文档片断节点（DocumentFragment）：11，对应常量Node.DOCUMENT_FRAGMENT_NODE</li><li>文档类型节点（DocumentType）：10，对应常量Node.DOCUMENT_TYPE_NODE</li><li>注释节点（Comment）：8，对应常量Node.COMMENT_NODE</li></ul></li><li><p>Node.prototype.nodeName</p><ul><li>文档节点（document）：#document</li><li>元素节点（element）：大写的标签名</li><li>属性节点（attr）：属性的名称</li><li>文本节点（text）：#text</li><li>文档片断节点（DocumentFragment）：#document-fragment</li><li>文档类型节点（DocumentType）：文档的类型</li><li>注释节点（Comment）：#comment</li></ul></li><li><p>Node.prototype.nodeValue<br>只有文本节点，注释节点，属性节点有文本值</p></li><li><p>Node.prototype.textContent<br>返回当前节点和后代节点的所有文本内容</p></li><li><p>Node.prototype.baseUrl<br>返回当前网页绝对路径的字符串，只读</p></li><li><p>Node.prototype.ownerDocument<br>返回当前节点所在的顶层文档对象，即<code>document</code></p></li><li><p>Node.prototype.nextSibling<br>返回后一个兄弟节点，包含文本节点和注释节点</p></li><li><p>Node.prototype.previousSibling<br>返回前一个兄弟节点</p></li><li><p>Node.prototype.parentNode<br>返回当前节点的父节点，三种可能，元素节点，文档节点，文档片段节点</p></li><li><p>Node.prototype.parentElement<br>返回当前节点的父元素节点</p></li><li><p>Node.prototype.firstChild, lastChild<br>返回当前节点的第一个与最后一个子节点，包含元素，文本注释节点</p></li><li><p>Node.prototype.childNodes<br>返回当前节点所有子节点组成的类数组对象</p></li><li><p>Node.prototype.isConnected<br>表示当前节点是否在文档之中</p></li><li><p>Node.prototype.</p></li></ol><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ol><li><p>Node.prototype.appendChild()<br>将参数节点插入某节点，返回值为参数节点</p></li><li><p>Node.prototype.hasChildNodes()<br>是否有子节点</p></li><li><p>Node.prototype.cloneNode(true)<br>克隆出一个节点，参数true表示同时克隆子节点，返回值新节点</p></li><li><p>Node.prototype.insertBefore(newCode, referenceNode)<br>将节点插入父节点内部的指定位置,返回插入的新结点</p></li><li><p>Node.prototype.removeChild()<br>从当前节点移除指定的节点，返回移除的子节点</p></li><li><p>Node.prototype.replaceChild(newChild, oldChild)<br>替换节点</p></li><li><p>Node.prototype.contains()</p><ul><li>参数节点为当前节点返回true</li><li>参数节点为当前节点子节点返回true</li><li>参数节点为当前节点后代节点返回true</li></ul></li><li><p>Node.prototype.compareDocumentPosition()  </p><ul><li>0 表示两个节点相同</li><li>1 不在同一个文档</li><li>2 参数节点在当前节点前面</li><li>4 在后面</li><li>8 参数节点包含当前节点</li><li>16 当前节点包含参数节点</li><li>32 浏览器内部使用</li></ul></li><li><p>Node.prototype.isEqualNode(), isSameNode()<br>检查两个节点是否相等；检查两个节点是否为同一个节点</p></li><li><p>Node.prototype.normalize()<br>清理当前节点内部的所有文本节点</p></li><li><p>Node.prototype.getRootNode()<br>字如其名，与<code>getOwnerDocument</code>相比可以获取<code>document</code>节点根节点不是<code>null</code>而是<code>document</code></p></li></ol><h3 id="三-NodeList接口与HTMLCollection接口"><a href="#三-NodeList接口与HTMLCollection接口" class="headerlink" title="三.NodeList接口与HTMLCollection接口"></a>三.NodeList接口与HTMLCollection接口</h3><h4 id="NodeList接口"><a href="#NodeList接口" class="headerlink" title="NodeList接口"></a>NodeList接口</h4><p><code>NodeList</code>是一个类数组对象，可以通过以下方法获得</p><ul><li>Node.childNodes</li><li>document.querySelectorAll()</li></ul><h5 id="实例属性方法"><a href="#实例属性方法" class="headerlink" title="实例属性方法"></a>实例属性方法</h5><ol><li><p>NodeList.prototype.length()<br>返回实例包含的节点数量</p></li><li><p>NodeList.prototype.forEach()<br>遍历</p></li><li><p>NodeList.prototype.keys(), values(), entries()<br>返回ES6的遍历器对象，可以通过for…of循环获取</p></li></ol><h4 id="HTMLCollection接口"><a href="#HTMLCollection接口" class="headerlink" title="HTMLCollection接口"></a>HTMLCollection接口</h4><p>节点对象的集合，只包含元素节点，只能用<code>for</code>循环遍历，只读，动态。<br>返回<code>HTMLCollection</code>实例的主要是<code>Document</code>对象的集合属性</p><h3 id="ParentNode接口和ChildNode接口"><a href="#ParentNode接口和ChildNode接口" class="headerlink" title="ParentNode接口和ChildNode接口"></a>ParentNode接口和ChildNode接口</h3><h4 id="ParentNode接口"><a href="#ParentNode接口" class="headerlink" title="ParentNode接口"></a>ParentNode接口</h4><ol><li><p>ParentNode.children<br>返回一个<code>HTMLCollection</code>实例，包含当前节点的所有子元素节点</p></li><li><p>ParentNode.firstElementChild, lastElementChild<br>返回当前节点的第一个子元素节点；最后一个</p></li><li><p>ParentNode.childElementCount<br>返回当前节点的所有元素子节点对象的数量</p></li><li><p>ParentNode.append(), ParentNode.prepend()<br>在当前节点的最后一个元素子节点后面/第一个元素子节点前面追加一个或多个子节点</p></li></ol><h4 id="ChildNode接口"><a href="#ChildNode接口" class="headerlink" title="ChildNode接口"></a>ChildNode接口</h4><ol><li><p>ChildNode.remove()<br>从父结点移除当前节点</p></li><li><p>ChildNode.before(), after()<br>在当前节点的前面/后面添加兄弟节点</p></li><li><p>ChildNode.replaceWith()<br>用参数节点替换当前节点</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;DOM&quot;&gt;&lt;a href=&quot;#DOM&quot; class=&quot;headerlink&quot; title=&quot;DOM&quot;&gt;&lt;/a&gt;DOM&lt;/h2&gt;&lt;h3 id=&quot;一-DOM节点&quot;&gt;&lt;a href=&quot;#一-DOM节点&quot; class=&quot;headerlink&quot; title=&quot;一.DOM节点&quot;&gt;&lt;/a&gt;一.DOM节点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Document: 文档顶层节点&lt;/li&gt;
&lt;li&gt;DocumentType: &lt;code&gt;doctype&lt;/code&gt;标签&lt;/li&gt;
&lt;li&gt;Element: 网页各种HTML标签&lt;/li&gt;
&lt;li&gt;Attr: 网页元素的属性&lt;/li&gt;
&lt;li&gt;Text: 标签之间或标签包含的文本&lt;/li&gt;
&lt;li&gt;Comment: 注释&lt;/li&gt;
&lt;li&gt;DocumentFragment: 文档的片段&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;浏览器提供一个原生节点对象&lt;code&gt;Node&lt;/code&gt;，上面其中节点都继承了&lt;code&gt;Node&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="personal-notes" scheme="https://uyc.gitee.io/categories/personal-notes/"/>
    
    
    <category term="JavaScript" scheme="https://uyc.gitee.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript知识点小记(3)</title>
    <link href="https://uyc.gitee.io/2020/08/25/personal-notes/JavaScript/js-notes3/"/>
    <id>https://uyc.gitee.io/2020/08/25/personal-notes/JavaScript/js-notes3/</id>
    <published>2020-08-25T07:38:00.000Z</published>
    <updated>2020-08-27T08:50:03.960Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p><code>Promise</code>是异步编程的一种解决方案，在js中实现为一个<code>Promise</code>对象<br>两个特点：  </p><ol><li>对象的状态不受外界影响，三种状态：   <code>pending</code>、<code>fulfilled</code>、<code>rejected</code>。</li><li>得到结果便不会再变，状态由进行变成成功或失败后便定型</li></ol><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本用法</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">/*异步操作成功*/</span>) &#123;</span><br><span class="line">        resolve(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//failure</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol><li><p>实例方法</p><ul><li>promise.prototype.then()</li><li>promise.prototype.catch() :<code>.then(null | undefined, rejection)</code>的别名，优先使用</li><li>promise.prototype.finally()<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">    .finally(<span class="function">() =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>静态方法</p></li></ol><ul><li><p>Promise.all()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3])</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">*  p状态由参数状态决定：</span></span><br><span class="line"><span class="comment">*   1. 全完成，p就是fulfilled，各Promise实例的返回值组成数组传递给p的回调</span></span><br><span class="line"><span class="comment">*   2. 有一个未完成，p就是rejected，第一个reject的Promise实例返回值就传递给p回调</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>Promise.race()</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race()</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  p状态由第一个先改变状态的实例决定</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li><p>Promise.allSettled()<br>状态总是fulfilled，该方法接受一组实例，等所有实例状态改变，返回所有返回值</p></li><li><p>Promise.any()</p></li><li><p>Promise.resolve()</p></li><li><p>Promise.reject()</p></li><li><p>Promise.try()</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Promise&quot;&gt;&lt;a href=&quot;#Promise&quot; class=&quot;headerlink&quot; title=&quot;Promise&quot;&gt;&lt;/a&gt;Promise&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Promise&lt;/code&gt;是异步编程的一种解决方案，在js中实现为一个&lt;code&gt;Promise&lt;/code&gt;对象&lt;br&gt;两个特点：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对象的状态不受外界影响，三种状态：   &lt;code&gt;pending&lt;/code&gt;、&lt;code&gt;fulfilled&lt;/code&gt;、&lt;code&gt;rejected&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;得到结果便不会再变，状态由进行变成成功或失败后便定型&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="personal-notes" scheme="https://uyc.gitee.io/categories/personal-notes/"/>
    
    
    <category term="JavaScript" scheme="https://uyc.gitee.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript知识点小记(2)</title>
    <link href="https://uyc.gitee.io/2020/08/24/personal-notes/JavaScript/js-notes2/"/>
    <id>https://uyc.gitee.io/2020/08/24/personal-notes/JavaScript/js-notes2/</id>
    <published>2020-08-24T06:36:00.000Z</published>
    <updated>2020-08-27T08:49:59.585Z</updated>
    
    <content type="html"><![CDATA[<h3 id="RegExp对象"><a href="#RegExp对象" class="headerlink" title="RegExp对象"></a>RegExp对象</h3><ol><li>实例属性<ul><li>RegExp.prototype.ignoreCase :是否设置i</li><li>RegExp.prototype.global :是否设置g</li><li>RegExp.prototype.multiline :是否设置m</li><li>RegExp.prototype.flags :返回设置的修饰符的字符串  </li><li>RegExp.prototype.lastIndex :返回整数，表示下一次搜索的开始位置</li><li>RegExp.prototype.source :返回正则的字符串形式，只读</li></ul></li></ol><a id="more"></a><ol start="2"><li><p>实例方法</p><ul><li>RegExp.prototype.test() :是否可以匹配</li><li>RegExp.prototype.exec() :返回匹配结果</li><li>字符串的那几个实力方法可以应用正则 取得较好的用处</li></ul></li><li><p>元字符</p><ul><li>点字符 (.)除换行空格什么的外匹配任意一个字符</li><li>位置字符 (^, &amp;)前者表示开头位置，后者表示结束位置</li><li>选择符 (|)或关系</li><li>转义符，反斜杠，元字符匹配需要前面加上反斜杠</li></ul></li></ol><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p><code>JSON</code>格式是一种用于数据交换的格式，取代繁重的<code>xml</code><br><code>JSON</code>对象是<code>js</code>原生对象<br><code>JSON.stringify()</code>方法用于将一个值转换成JSON字符串<br><code>JSON.parse()</code>方法用于将JSON字符串转换成值</p><h3 id="绑定this的方法"><a href="#绑定this的方法" class="headerlink" title="绑定this的方法"></a>绑定this的方法</h3><ul><li>Function.prototype.call()<br>指定函数内部this的指向，第一个参数为指向的对象，后面的为运行参数</li><li>Function.prototype.apply()<br>和<code>call</code>的区别是运行传参为传入数组传参</li><li>Function.prototype.bind()<br>将函数体内的this绑定到某个对象，并返回一个新函数</li></ul><h3 id="instanceof运算符"><a href="#instanceof运算符" class="headerlink" title="instanceof运算符"></a>instanceof运算符</h3><p>该运算符左边是实例对象，右边是构造函数，返回右边构造函数的原型对象是否在实例对象的原型链上</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;RegExp对象&quot;&gt;&lt;a href=&quot;#RegExp对象&quot; class=&quot;headerlink&quot; title=&quot;RegExp对象&quot;&gt;&lt;/a&gt;RegExp对象&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;实例属性&lt;ul&gt;
&lt;li&gt;RegExp.prototype.ignoreCase :是否设置i&lt;/li&gt;
&lt;li&gt;RegExp.prototype.global :是否设置g&lt;/li&gt;
&lt;li&gt;RegExp.prototype.multiline :是否设置m&lt;/li&gt;
&lt;li&gt;RegExp.prototype.flags :返回设置的修饰符的字符串  &lt;/li&gt;
&lt;li&gt;RegExp.prototype.lastIndex :返回整数，表示下一次搜索的开始位置&lt;/li&gt;
&lt;li&gt;RegExp.prototype.source :返回正则的字符串形式，只读&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="personal-notes" scheme="https://uyc.gitee.io/categories/personal-notes/"/>
    
    
    <category term="JavaScript" scheme="https://uyc.gitee.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript知识点小记(1)</title>
    <link href="https://uyc.gitee.io/2020/08/23/personal-notes/JavaScript/js-notes1/"/>
    <id>https://uyc.gitee.io/2020/08/23/personal-notes/JavaScript/js-notes1/</id>
    <published>2020-08-23T13:06:00.000Z</published>
    <updated>2020-08-27T08:49:55.080Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-数组静态方法"><a href="#1-数组静态方法" class="headerlink" title="1.数组静态方法"></a>1.数组静态方法</h3><ul><li>Array.isArray() :辨别是否是数组，弥补typeof运算符的不足</li></ul><a id="more"></a><h3 id="2-数组实例方法"><a href="#2-数组实例方法" class="headerlink" title="2.数组实例方法"></a>2.数组实例方法</h3><ul><li>push()<br>往数组后面添加元素</li><li>pop()<br>删除数组最后一个元素并返回该元素</li><li>shift()<br>删除数组第一个元素并返回</li><li>unshift()<br>在数组第一个位置添加元素并返回新数组长度</li><li>join()<br>以参数作为分隔符将所有元素拼接成字符串，无参用逗号</li><li>concat()<br>用于多数组的合并，原数组不变</li><li>reverse()<br>颠倒数组排列并返回颠倒后的数组</li><li>slice()<br>提取数组中的一部分，返回新数组，原数组不变</li><li>splice()<br>用新元素替换原数组的一部分，返回被删除的元素</li><li>sort()<br>排序<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>].sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br></pre></td></tr></table></figure></li><li>map()<br>遍历数组，返回值组成新数组，原数组不变</li><li>forEach()<br>遍历数组，操作数据，无法中断，没返回值</li><li>filter()<br>过滤，满足条件的组成新数组返回，原数组不变</li><li>some(), every()<br>判断数组成员是否满足某个条件，前者some满足即true，后者需every</li><li>reduce(), reduceRight()<br>依次处理数组成员，最终累计成一个值，前者左开头，后者右开头</li><li>indexOf(), lastIndexOf()<br>返回元素出现的位置，前者为第一次出现的位置，后者为最后一次出现的位置</li></ul><h3 id="3-String实例方法"><a href="#3-String实例方法" class="headerlink" title="3.String实例方法"></a>3.String实例方法</h3><ul><li>String.prototype.concat() :拼接</li><li>String.prototype.slice() :取值</li><li>String。prototype.substring :取值(建议使用slice)</li><li>String.prototype.substr() :取值(第二个参数不是结束位，而是取值长度)</li><li>String.prototype.indexOf, String.prototype.lastIndexOf() :同数组</li><li>String.prototype.trim() :去除两端空格，不变原数组</li><li>String.prototype.toLowerCase(), toUpperCase() :全体大小写，不变原数组</li><li>String.prototype.match() :匹配子字符串，可正则</li><li>String.prototype.search(), replace() :可正则</li><li>String.prototype.split() :按参数分割字符串 可正则</li><li>String.prototype.localCompare() :比大小(奇怪的东西)</li></ul><h3 id="4-Math静态方法"><a href="#4-Math静态方法" class="headerlink" title="4.Math静态方法"></a>4.Math静态方法</h3><ul><li>Math.abs() :绝对值</li><li>Math.ceil() :向上取整</li><li>Math.floor() :向下取整</li><li>Math.max() :最大值</li><li>Math.min() :最小值</li><li>Math.pow() :幂运算</li><li>Math.sqrt() :平方根</li><li>Math.log() :自然对数</li><li>Math.exp() :e 的指数</li><li>Math.round() :四舍五入</li><li>Math.random() :随机数</li><li>三角函数方法</li></ul><h3 id="5-Date静态方法"><a href="#5-Date静态方法" class="headerlink" title="5.Date静态方法"></a>5.Date静态方法</h3><ul><li>Date.now() :返回距离时间零点的毫秒数</li><li>Date.parse() :返回字符串参数时间距离零点的毫秒数</li><li>Date.UTC() :返回参数UTC标准距离零点的毫秒数</li></ul><h3 id="6-Date实例方法"><a href="#6-Date实例方法" class="headerlink" title="6.Date实例方法"></a>6.Date实例方法</h3><p>大致可分三类：</p><ol><li>to类: 从Date对象返回一个字符串，表示特定的时间</li><li>get类: 获取Date对象的日期和时间</li><li>set类: 设置Date对象的日期和时间</li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-数组静态方法&quot;&gt;&lt;a href=&quot;#1-数组静态方法&quot; class=&quot;headerlink&quot; title=&quot;1.数组静态方法&quot;&gt;&lt;/a&gt;1.数组静态方法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Array.isArray() :辨别是否是数组，弥补typeof运算符的不足&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="personal-notes" scheme="https://uyc.gitee.io/categories/personal-notes/"/>
    
    
    <category term="JavaScript" scheme="https://uyc.gitee.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript知识点小记(0)</title>
    <link href="https://uyc.gitee.io/2020/08/22/personal-notes/JavaScript/js-notes0/"/>
    <id>https://uyc.gitee.io/2020/08/22/personal-notes/JavaScript/js-notes0/</id>
    <published>2020-08-22T12:23:00.000Z</published>
    <updated>2020-08-27T08:49:50.023Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h3><p>JavaScript语言共6种数据类型（<code>ES6</code>新增<code>Symbol</code>类型，现提出第八种<code>BigInt</code>）</p><ul><li>Number    (数值)</li><li>String    (字符串)</li><li>Boolean    (布尔值)</li><li>Undefined   (未定义)</li><li>Null    (空值)</li><li>Object    (对象，包括数组、函数)</li></ul><a id="more"></a><h3 id="2-typeof运算符"><a href="#2-typeof运算符" class="headerlink" title="2.typeof运算符"></a>2.typeof运算符</h3><p>可以确定一个值的类型，同样的方法有<code>instanceof</code>运算符、<code>Object.prototype.toString</code>方法.</p><h3 id="3-数值相关全局方法"><a href="#3-数值相关全局方法" class="headerlink" title="3.数值相关全局方法"></a>3.数值相关全局方法</h3><ul><li>parseInt() 用于将字符串转换成数字</li><li>parseFloat() 将字符串转换成浮点数</li><li>isNaN() 判断值是否为NaN</li><li>isFinite() 表示某个值是否为正常的数值</li></ul><h3 id="4-throw语句"><a href="#4-throw语句" class="headerlink" title="4.throw语句"></a>4.throw语句</h3><p><code>throw</code>语句的作用是手动中断程序执行，抛出一个错误</p><h3 id="5-try…catch…finally结构"><a href="#5-try…catch…finally结构" class="headerlink" title="5.try…catch…finally结构"></a>5.try…catch…finally结构</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> error(<span class="string">&#x27;error!&#x27;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.name + <span class="string">&#x27;:&#x27;</span> + e.message)</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;finally&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>try</code>代码将抛出一个错误，<code>catch</code>捕获到错误并执行代码，不管有没有发生错误，<code>finally</code>都会执行</p><h3 id="6-Object静态方法"><a href="#6-Object静态方法" class="headerlink" title="6.Object静态方法"></a>6.Object静态方法</h3><ol><li>遍历对象属性<ul><li>Object.keys() :传入对象，返回包含对象属性名的数组</li><li>Object.getOwnPropertyNames() :同<code>keys</code>类似，但返回数组包含不可枚举属性</li></ul></li><li>对象属性模型的相关方法<ul><li>Object.getOwnPropertyDescriptor() :获取某个属性的描述对象</li><li>Object.defineProperty() :通过描述对象，定义某个属性</li><li>Object.defineProperties() :通过描述对象，定义多个属性</li></ul></li><li>控制对象状态的方法<ul><li>Object.preventExtensions() :防止对象扩展</li><li>Object.isExtensible() :判断对象是否可扩展</li><li>Object.seal() :禁止对象配置</li><li>Object.isSealed() :判断一个对象是否可配置</li><li>Object.freeze() :冻结一个对象</li><li>Object.isFrozen() :判断一个对象是否被冻结</li></ul></li><li>原型链相关方法<ul><li>Object.create() :指定原型对象和属性，返回一个新的对象</li><li>Object.getPrototypeOf() :获取对象的<code>prototype</code>对象</li></ul></li></ol><h3 id="7-Object实例方法"><a href="#7-Object实例方法" class="headerlink" title="7.Object实例方法"></a>7.Object实例方法</h3><ul><li>Object.prototype.valueOf() :返回当前对象对应的值</li><li>Object.prototype.toString() :返回当前对象对应的字符串形式</li><li>Object.prototype.toLocaleString() :返回当前对象对应的本地字符串形式</li><li>Object.prototype.hasOwnProperty() :判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性</li><li>Object.prototype.isPrototypeOf() :判断当前对象是否为另一个对象的原型</li><li>Object.prototype.propertyIsEnumerable() :判断某个属性是否可枚举</li></ul><h3 id="8-属性描述对象"><a href="#8-属性描述对象" class="headerlink" title="8.属性描述对象"></a>8.属性描述对象</h3><ol><li>属性描述对象元属性<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    value: <span class="literal">undefined</span>,                 <span class="comment">//该属性属性值</span></span><br><span class="line">    writable: <span class="literal">true</span>,                  <span class="comment">//表示该属性是否可改写</span></span><br><span class="line">    enumerable: <span class="literal">true</span>,               <span class="comment">//属性是否可遍历</span></span><br><span class="line">    configurable: <span class="literal">true</span>,            <span class="comment">//属性描述对象是否可改，value不算</span></span><br><span class="line">    get: <span class="literal">undefined</span>,                 <span class="comment">//取值函数getter</span></span><br><span class="line">    set: <span class="literal">undefined</span>                  <span class="comment">//存值函数setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Object.getOwnPropertyDescriptor(obj, ‘proName’)<br>该方法可获取对象自身属性的描述对象</li><li>Object.getOwnPropertyNames()<br>返回所有属性名组成的数组，包含不可遍历属性</li><li>Object.defineProperty(object, propertyName, attributesObject),Object.defineProperties(Object, propertyObject)<ul><li>object :属性所在对象</li><li>propertyName :属性名，string</li><li>attributesObject :属性描述对象</li><li>propertyObject :属性对象,例{p1: { value: 1, enumerable: false }}</li></ul></li><li>Object.prototype.propertyIsEnumerable()<br>判断对象自身属性是否可遍历</li><li>存取器（getter(), setter()）<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存取器常用于属性值依赖于对像内部数据的场合</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    $n = <span class="number">5</span>,</span><br><span class="line">    <span class="keyword">get</span> <span class="title">next</span>() &#123; <span class="keyword">return</span> <span class="built_in">this</span>.$n++ &#125;,</span><br><span class="line">    <span class="keyword">set</span> <span class="title">next</span>(<span class="params">n</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt;= <span class="built_in">this</span>.$n) &#123;</span><br><span class="line">            <span class="built_in">this</span>. $n = n</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;新的值必须大于当前值&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.next    <span class="comment">// 5</span></span><br><span class="line">obj.next = <span class="number">10</span></span><br><span class="line">obj.next    <span class="comment">// 10</span></span><br><span class="line">obj.next = <span class="number">5</span></span><br><span class="line"><span class="comment">// Uncaught Error: 新的值必须大于当前值</span></span><br></pre></td></tr></table></figure></li><li>拷贝对象<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> extend = <span class="function"><span class="keyword">function</span> (<span class="params">to, from</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> property <span class="keyword">in</span> <span class="keyword">from</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">from</span>.hasOwnProperty(property)) <span class="keyword">continue</span>    <span class="comment">// 过滤继承属性</span></span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(</span><br><span class="line">            to,</span><br><span class="line">            property,</span><br><span class="line">            <span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="keyword">from</span>, property)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> to</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>控制对象状态<ul><li>Object.preventExtensions(obj) :使对象无法添加新属性</li><li>Object.isExtensible(obj) :检查是否无法添加新属性</li><li>Object.seal(obj) :是对象无法添加新属性，也无法删除，等同于false掉configurable</li><li>Object.isSealed(obj) :检查是否用过seal</li><li>Object.freeze(obj) :使对象无法做出修改，变成常量一般的存在</li><li>Object.isFrozen(obj) :检查是否用过freeze</li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-数据类型&quot;&gt;&lt;a href=&quot;#1-数据类型&quot; class=&quot;headerlink&quot; title=&quot;1.数据类型&quot;&gt;&lt;/a&gt;1.数据类型&lt;/h3&gt;&lt;p&gt;JavaScript语言共6种数据类型（&lt;code&gt;ES6&lt;/code&gt;新增&lt;code&gt;Symbol&lt;/code&gt;类型，现提出第八种&lt;code&gt;BigInt&lt;/code&gt;）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Number    (数值)&lt;/li&gt;
&lt;li&gt;String    (字符串)&lt;/li&gt;
&lt;li&gt;Boolean    (布尔值)&lt;/li&gt;
&lt;li&gt;Undefined   (未定义)&lt;/li&gt;
&lt;li&gt;Null    (空值)&lt;/li&gt;
&lt;li&gt;Object    (对象，包括数组、函数)&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="personal-notes" scheme="https://uyc.gitee.io/categories/personal-notes/"/>
    
    
    <category term="JavaScript" scheme="https://uyc.gitee.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>音乐播放器项目知识点(1)</title>
    <link href="https://uyc.gitee.io/2020/08/21/tech-notes/cloudmusic/cloudmusic-note1/"/>
    <id>https://uyc.gitee.io/2020/08/21/tech-notes/cloudmusic/cloudmusic-note1/</id>
    <published>2020-08-21T08:55:00.000Z</published>
    <updated>2020-08-22T12:22:12.991Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://gitee.com/uyc/vue-cloudmusic">音乐播放器项目</a>知识点（1）</p><a id="more"></a><ul><li><a href="#first">0.vue-lazyload图片懒加载</a></li><li><a href="#second">1.网页的全屏</a></li></ul><h2 id="first" style="display:block"></h2><h2 id="1-使用v-lazyload插件实现图片懒加载"><a href="#1-使用v-lazyload插件实现图片懒加载" class="headerlink" title="1.使用v-lazyload插件实现图片懒加载"></a>1.使用v-lazyload插件实现图片懒加载</h2><p>图片懒加载在项目开发里比较常用，使用<code>vue-lazyload</code>先在生产环境安装插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i vue-lazyload</span><br></pre></td></tr></table></figure><p>使用很简单，在img标签中添加v-lazy属性写上图片地址即可</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">v-lazy</span>=<span class="string">&quot;imgUrl&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="second" style="display:block"></h2><h2 id="2-实现网页全屏与退出"><a href="#2-实现网页全屏与退出" class="headerlink" title="2.实现网页全屏与退出"></a>2.实现网页全屏与退出</h2><p><code>document</code>自带<code>requestFullscreen</code>方法可以全屏模式，退出使用自带的<code>exitFullscreen</code>方法，判断是否全屏模式有<code>fullScreen</code>方法，为了兼容可以使用以下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进入全屏模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestFullscreen</span>(<span class="params">ele</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ele.requestFullscreen) &#123;</span><br><span class="line">        ele.requestFullscreen()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ele.msRequestFullscreen) &#123;</span><br><span class="line">        ele.msRequestFullscreen()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ele.mozRequestFullScreen) &#123;</span><br><span class="line">        ele.mozRequestFullScreen()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ele.webkitRequestFullScreen) &#123;</span><br><span class="line">        ele.webkitRequestFullScreen()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 退出全屏模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">exitFullscreen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> pDoc = <span class="built_in">window</span>.parent.document</span><br><span class="line">    <span class="keyword">if</span> (pDoc.exitFullscreen) &#123;</span><br><span class="line">        pDoc.exitFullscreen()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pDoc.msExitFullscreen) &#123;</span><br><span class="line">        pDoc.msRequestFullscreen()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pDoc.mozCancelFullScreen) &#123;</span><br><span class="line">        pDoc.mozRequestFullScreen()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pDoc.webkitCancelFullScreen) &#123;</span><br><span class="line">        pDoc.webkitRequestFullScreen()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断是否全屏</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFullScreen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.fullScreen ||</span><br><span class="line">        <span class="built_in">document</span>.mozFullScreen ||</span><br><span class="line">        <span class="built_in">document</span>.webkitIsFullScreen</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://gitee.com/uyc/vue-cloudmusic&quot;&gt;音乐播放器项目&lt;/a&gt;知识点（1）&lt;/p&gt;</summary>
    
    
    
    <category term="tech-notes" scheme="https://uyc.gitee.io/categories/tech-notes/"/>
    
    
    <category term="JavaScript" scheme="https://uyc.gitee.io/tags/JavaScript/"/>
    
    <category term="Vue" scheme="https://uyc.gitee.io/tags/Vue/"/>
    
    <category term="vue-lazyload" scheme="https://uyc.gitee.io/tags/vue-lazyload/"/>
    
  </entry>
  
  <entry>
    <title>来自风平浪静的明天</title>
    <link href="https://uyc.gitee.io/2020/08/20/essay/from-a-calm-tomorrow/"/>
    <id>https://uyc.gitee.io/2020/08/20/essay/from-a-calm-tomorrow/</id>
    <published>2020-08-20T07:43:00.000Z</published>
    <updated>2020-08-27T14:46:22.715Z</updated>
    
    <content type="html"><![CDATA[<p>昨天一天把来自风平浪静的明天这部番刷完了，刷完之后就一直难受，莫名的难受。</p><a id="more"></a><p>以前看完一部番也会有一些触动，他们的故事到这就完结了，就挺怀念的。</p><p>但昨天的难受不一样。</p><p>看到他们的happy-end，有遗憾，有解脱，有幸福，为他们开心。</p><p>他们的情感纠葛很真实，很单纯，很容易从他们故事里看到自己的经历。</p><img src="../../../../../images/from-a-calm-tomorrow/千咲.jpg" style="width:100%;"><p>最心疼里面的千咲了，因为罪恶感一直将自己的感情束缚着，还好有个高智商的纺喜欢上了她，能够把她拉回来。</p><p>还有喜欢着她的要，为了不让她一直难受着，一直在努力的推动着光和爱花的感情，即使这会使得千咲讨厌他。审视自己，又有几分像呢？</p><p>虽然结局美海很遗憾，不过看起来她似乎已经解脱了，将自己对光的爱转为对光和爱华的祝福。结局淳还喜欢着她，他们应该会在一起吧，希望她能幸福。</p><img src="../../../../../images/from-a-calm-tomorrow/from-tomorrow.jpeg" style="width:100%;"><p>他们的故事就这样结束了，挺多感悟的，我的生活还在继续，我还有很多人要相遇，还有很多事要经历，祝福自己。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;昨天一天把来自风平浪静的明天这部番刷完了，刷完之后就一直难受，莫名的难受。&lt;/p&gt;</summary>
    
    
    
    <category term="essay" scheme="https://uyc.gitee.io/categories/essay/"/>
    
    
    <category term="anime" scheme="https://uyc.gitee.io/tags/anime/"/>
    
    <category term="life" scheme="https://uyc.gitee.io/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>音乐播放器项目知识点(0)</title>
    <link href="https://uyc.gitee.io/2020/08/10/tech-notes/cloudmusic/cloudmusic-note0/"/>
    <id>https://uyc.gitee.io/2020/08/10/tech-notes/cloudmusic/cloudmusic-note0/</id>
    <published>2020-08-10T11:30:00.000Z</published>
    <updated>2020-08-22T12:22:10.210Z</updated>
    
    <content type="html"><![CDATA[<p>在这里我会把开发<a href="https://gitee.com/uyc/vue-cloudmusic">音乐播放器项目</a>中遇到的知识点记下来，方便自己学习，同时是对自己的记录。</p><a id="more"></a><ul><li><a href="#first">0.Vue批量注册组件</a></li><li><a href="#second">1.移动端适配方案Rem</a></li><li><a href="#third">2.Vue按需导入Element-UI组件</a></li></ul><h2 id="first" style="display:block"></h2><h2 id="1-Vue批量注册组件"><a href="#1-Vue批量注册组件" class="headerlink" title="1.Vue批量注册组件"></a>1.Vue批量注册组件</h2><p>学习一个新项目时遇到的一个知识点，复用率高的基础组件可以批量进行注册</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">install(Vue) &#123;</span><br><span class="line">    <span class="keyword">const</span> requireComponent = <span class="built_in">require</span>.context(</span><br><span class="line">        <span class="string">&quot;@/components/base&quot;</span>, <span class="comment">// 引入组件的根目录</span></span><br><span class="line">        <span class="literal">true</span>, <span class="comment">//是否需要查找下级目录</span></span><br><span class="line">        /[a-z0<span class="number">-9</span>]+\.(jsx?|vue)$/i</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 批量注册基础组件</span></span><br><span class="line">    requireComponent.keys().forEach(<span class="function"><span class="params">fileName</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 当前获取组件的配置数据</span></span><br><span class="line">        <span class="keyword">const</span> componentConfig = requireComponent(fileName)</span><br><span class="line">        <span class="comment">// 获取该组件的 default.name 属性</span></span><br><span class="line">        <span class="keyword">const</span> componentName = componentConfig.default.name</span><br><span class="line">        <span class="keyword">if</span> (componentName) &#123;</span><br><span class="line">            <span class="comment">// 注册组件</span></span><br><span class="line">            Vue.component(componentName, componentConfig.default || componentConfig)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="second" style="display:block"></h2><h2 id="2-移动端适配方案Rem"><a href="#2-移动端适配方案Rem" class="headerlink" title="2.移动端适配方案Rem"></a>2.移动端适配方案Rem</h2><p>使用<code>rem</code>进行移动端适配是现在主流的适配方案，需要将设计师的<code>px</code>稿件转换成<code>rem</code>，然后用<code>js</code>实现根字体随屏幕尺寸变换，从而达到移动端适配的效果。我这次项目学习了使用<code>postcss-pxtorem</code>插件进行<code>rem</code>自动计算。</p><h3 id="postcss-pxtorem插件的使用"><a href="#postcss-pxtorem插件的使用" class="headerlink" title="postcss-pxtorem插件的使用"></a>postcss-pxtorem插件的使用</h3><p>先在开发环境安装插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D postcss-pxtorem</span><br></pre></td></tr></table></figure><p>接着在<code>package.json</code>文件中配置插件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;postcss&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;plugins&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;autoprefixer&quot;</span>: &#123;&#125;,</span><br><span class="line">      <span class="string">&quot;postcss-pxtorem&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;rootValue&quot;</span>: <span class="number">14</span>,    <span class="comment">//设计稿根字体尺寸</span></span><br><span class="line">        <span class="string">&quot;propList&quot;</span>: [       <span class="comment">//需要转换的元素列表</span></span><br><span class="line">          <span class="string">&quot;*&quot;</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>现在已经可以将<code>px</code>转换成<code>rem</code>了，接下来要根据设备屏幕尺寸变换根字体尺寸，需要在vue程序入口加载一个<code>rem.js</code>文件,我这里还使用了<code>lodash-es</code>插件实现<code>函数节流(throttle)</code>,先安装插件再使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save lodash-es</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//rem.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; throttle &#125; <span class="keyword">from</span> <span class="string">&#x27;lodash-es&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> baseSize = <span class="number">14</span></span><br><span class="line"><span class="keyword">let</span> htmlFontSize</span><br><span class="line">!(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> calc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这里限制根字体在14~18之间，太小太大不好看</span></span><br><span class="line">        <span class="keyword">const</span> maxFontSize = <span class="number">18</span></span><br><span class="line">        <span class="keyword">const</span> minFontSize = <span class="number">14</span></span><br><span class="line">        <span class="keyword">const</span> html = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;html&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">const</span> width = html.clientWidth</span><br><span class="line">        <span class="comment">// 1440为设计搞尺寸，这里计算变换后的根字体尺寸</span></span><br><span class="line">        <span class="keyword">let</span> size = baseSize * (width / <span class="number">1440</span>)</span><br><span class="line">        size = <span class="built_in">Math</span>.min(maxFontSize, size)</span><br><span class="line">        size = <span class="built_in">Math</span>.max(minFontSize, size)</span><br><span class="line">        html.style.fontSize = size + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    calc()</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;resize&#x27;</span>, throttle(calc(), <span class="number">500</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="third" style="display:block"></h2><h2 id="3-Vue按需导入Element-UI组件"><a href="#3-Vue按需导入Element-UI组件" class="headerlink" title="3.Vue按需导入Element-UI组件"></a>3.Vue按需导入Element-UI组件</h2><p>使用<code>babel-plugin-component</code>插件进行插件管理<br>安装<code>babel-plugin-component</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D babel-plugin-component</span><br></pre></td></tr></table></figure><p>安装<code>element-ui</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i element-ui</span><br></pre></td></tr></table></figure><p>在<code>babel.config.js</code>中添加配置<code>element-ui</code>插件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">plugin: [</span><br><span class="line">    [</span><br><span class="line">        <span class="string">&#x27;component&#x27;</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                libraryName: <span class="string">&#x27;element-ui&#x27;</span>,</span><br><span class="line">                styleLibraryName: <span class="string">&#x27;theme-chalk&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">    ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>接着就可以按需加载element-ui组件</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在这里我会把开发&lt;a href=&quot;https://gitee.com/uyc/vue-cloudmusic&quot;&gt;音乐播放器项目&lt;/a&gt;中遇到的知识点记下来，方便自己学习，同时是对自己的记录。&lt;/p&gt;</summary>
    
    
    
    <category term="tech-notes" scheme="https://uyc.gitee.io/categories/tech-notes/"/>
    
    
    <category term="Vue" scheme="https://uyc.gitee.io/tags/Vue/"/>
    
    <category term="Element-UI" scheme="https://uyc.gitee.io/tags/Element-UI/"/>
    
    <category term="postcss-pxtorem" scheme="https://uyc.gitee.io/tags/postcss-pxtorem/"/>
    
  </entry>
  
</feed>
